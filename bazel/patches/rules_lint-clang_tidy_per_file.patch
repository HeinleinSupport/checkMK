diff --git a/lint/clang_tidy.bzl b/lint/clang_tidy.bzl
index 126b7fd..3be72a9 100644
--- a/lint/clang_tidy.bzl
+++ b/lint/clang_tidy.bzl
@@ -341,7 +341,8 @@ def clang_tidy_action(ctx, compilation_context, executable, srcs, stdout, exit_c
             stdout = stdout,
             exit_code = exit_code,
             mnemonic = _MNEMONIC,
-            progress_message = "Linting %{label} with clang-tidy",
+            progress_message = "Linting %{{label}}:{} with clang-tidy".format(srcs[0].basename),
+            patch_cfg_name = "{}_rules_lint/{}".format(ctx.label.name, srcs[0].short_path),
         )
     else:
         # Use run_shell for lint mode
@@ -367,7 +368,7 @@ def clang_tidy_action(ctx, compilation_context, executable, srcs, stdout, exit_c
             arguments = [executable._clang_tidy.path] + clang_tidy_args + ["--", compiler_args_obj],
             env = env,
             mnemonic = _MNEMONIC,
-            progress_message = "Linting %{label} with clang-tidy",
+            progress_message = "Linting %{{label}}:{} with clang-tidy".format(srcs[0].basename),
         )
 
 # buildifier: disable=function-docstring
@@ -386,29 +387,31 @@ def _clang_tidy_aspect_impl(target, ctx):
                                    [implementation_dep[CcInfo].compilation_context for implementation_dep in ctx.rule.attr.implementation_deps],
         )
 
-    if ctx.attr._options[LintOptionsInfo].fix:
-        outputs, info = patch_and_output_files(_MNEMONIC, target, ctx)
-    else:
-        outputs, info = output_files(_MNEMONIC, target, ctx)
-
     if len(files_to_lint) == 0:
+        outputs, info = patch_and_output_files(_MNEMONIC, target, ctx)
         noop_lint_action(ctx, outputs)
         return [info]
 
-    clang_tidy_action(
-        ctx,
-        compilation_context,
-        ctx.executable,
-        files_to_lint,
-        outputs.human.out,
-        outputs.human.exit_code,
-        patch = getattr(outputs, "patch", None),
-    )
+    if ctx.attr._options[LintOptionsInfo].fix:
+        outputs, info = patch_and_output_files(_MNEMONIC, target, ctx, files_to_lint = files_to_lint)
+    else:
+        outputs, info = output_files(_MNEMONIC, target, ctx, files_to_lint = files_to_lint)
+
+    for output, file in zip(outputs, files_to_lint):
+        clang_tidy_action(
+            ctx,
+            compilation_context,
+            ctx.executable,
+            [file],
+            output.human.out,
+            output.human.exit_code,
+            patch = getattr(output, "patch", None),
+        )
 
-    # TODO(alex): if we run with --fix, this will report the issues that were fixed. Does a machine reader want to know about them?
-    raw_machine_report = ctx.actions.declare_file(OUTFILE_FORMAT.format(label = target.label.name, mnemonic = _MNEMONIC, suffix = "raw_machine_report"))
-    clang_tidy_action(ctx, compilation_context, ctx.executable, files_to_lint, raw_machine_report, outputs.machine.exit_code)
-    parse_to_sarif_action(ctx, _MNEMONIC, raw_machine_report, outputs.machine.out)
+        # TODO(alex): if we run with --fix, this will report the issues that were fixed. Does a machine reader want to know about them?
+        raw_machine_report = ctx.actions.declare_file(OUTFILE_FORMAT.format(label = target.label.name + "_rules_lint/" + file.short_path, mnemonic = _MNEMONIC, suffix = "raw_machine_report"))
+        clang_tidy_action(ctx, compilation_context, ctx.executable, [file], raw_machine_report, output.machine.exit_code)
+        parse_to_sarif_action(ctx, _MNEMONIC, raw_machine_report, output.machine.out)
     return [info]
 
 DEFAULT_RULE_KINDS = ["cc_binary", "cc_library"]
diff --git a/lint/lint_test.bzl b/lint/lint_test.bzl
index 8e2d588..fd6d9a9 100644
--- a/lint/lint_test.bzl
+++ b/lint/lint_test.bzl
@@ -39,24 +39,26 @@ load("@bazel_lib//lib:paths.bzl", "to_rlocation_path")
 
 def _write_assert(ctx, files):
     "Create a parameter to substitute into the shell script"
-    output = None
-    exit_code = None
+    outputs = []
+    exit_codes = []
     for f in files.to_list():
         if f.path.endswith(".out"):
-            output = f
+            outputs.append(f)
         elif f.path.endswith(".exit_code"):
-            exit_code = f
+            exit_codes.append(f)
         else:
             fail("rules_lint_human output group contains unrecognized file extension: ", f.path)
-    if output and exit_code:
-        return "assert_exit_code_zero '{}' '{}'".format(to_rlocation_path(ctx, exit_code), to_rlocation_path(ctx, output))
-    if output:
-        return "assert_output_empty '{}'".format(to_rlocation_path(ctx, output))
+    if outputs and exit_codes:
+        if len(outputs) != len(exit_codes):
+            fail("mismatch between outputs and exit_codes", outputs, exit_codes)
+        return ["assert_exit_code_zero '{}' '{}'".format(to_rlocation_path(ctx, e), to_rlocation_path(ctx, o)) for e, o in zip(exit_codes, outputs)]
+    if outputs:
+        return ["assert_output_empty '{}'".format(to_rlocation_path(ctx, o)) for o in outputs]
     fail("missing output file among", files)
 
 def _test_impl(ctx):
     bin = ctx.actions.declare_file("{}.lint_test.sh".format(ctx.label.name))
-    asserts = [_write_assert(ctx, src[OutputGroupInfo].rules_lint_human) for src in ctx.attr.srcs]
+    asserts = [a for src in ctx.attr.srcs for a in _write_assert(ctx, src[OutputGroupInfo].rules_lint_human)]
 
     runfiles = ctx.runfiles(transitive_files = depset(transitive = [src[OutputGroupInfo].rules_lint_human for src in ctx.attr.srcs]))
     runfiles = runfiles.merge(ctx.attr._runfiles_lib[DefaultInfo].default_runfiles)
diff --git a/lint/private/lint_aspect.bzl b/lint/private/lint_aspect.bzl
index 47fc580..f6c5be4 100644
--- a/lint/private/lint_aspect.bzl
+++ b/lint/private/lint_aspect.bzl
@@ -54,7 +54,7 @@ def should_visit(rule, allow_kinds, allow_filegroup_tags = []):
 
 OUTFILE_FORMAT = "{label}.{mnemonic}.{suffix}"
 
-def output_files(mnemonic, target, ctx, sibling = None):
+def output_files(mnemonic, target, ctx, sibling = None, files_to_lint = None):
     """Declare linter output files.
 
     Args:
@@ -63,65 +63,116 @@ def output_files(mnemonic, target, ctx, sibling = None):
         ctx: the aspect context
         sibling: optional File to declare outputs as siblings of, placing them in
             the same directory as the sibling file.
+        files_to_lint: optional list of files, if provided one output will be created per file
 
     Returns:
-        tuple of struct() of output files, and the OutputGroupInfo provider that the rule should return
+        tuple of struct() of output files, and the OutputGroupInfo provider that the rule should return when files_to_lint is None
+        tuple of list of struct() of output files, and the OutputGroupInfo provider when files_to_lint is provided
     """
-    human_out = ctx.actions.declare_file(OUTFILE_FORMAT.format(label = target.label.name, mnemonic = mnemonic, suffix = "out"), sibling = sibling)
-
-    # NB: named ".report" as there are existing callers depending on that
-    machine_out = ctx.actions.declare_file(OUTFILE_FORMAT.format(label = target.label.name, mnemonic = mnemonic, suffix = "report"), sibling = sibling)
-
-    if ctx.attr._options[LintOptionsInfo].fail_on_violation:
-        # Fail on violation means the exit code is reported to Bazel as the action result
-        human_exit_code = None
-        machine_exit_code = None
-    else:
-        # The exit codes should instead be provided as action outputs so the build succeeds.
-        # Downstream tooling like `aspect lint` will be responsible for reading the exit codes
-        # and interpreting them.
-        human_exit_code = ctx.actions.declare_file(OUTFILE_FORMAT.format(label = target.label.name, mnemonic = mnemonic, suffix = "out.exit_code"), sibling = sibling)
-        machine_exit_code = ctx.actions.declare_file(OUTFILE_FORMAT.format(label = target.label.name, mnemonic = mnemonic, suffix = "report.exit_code"), sibling = sibling)
-
-    human_outputs = [f for f in [human_out, human_exit_code] if f]
-    machine_outputs = [f for f in [machine_out, machine_exit_code] if f]
-    return struct(
-        human = struct(
-            out = human_out,
-            exit_code = human_exit_code,
-        ),
-        machine = struct(
-            out = machine_out,
-            exit_code = machine_exit_code,
-        ),
-    ), OutputGroupInfo(
+    human_outputs = []
+    machine_outputs = []
+
+    def _declare_outputs(suffix = ""):
+        """Helper function to declare the outputs"""
+        human_out = ctx.actions.declare_file(OUTFILE_FORMAT.format(label = target.label.name + suffix, mnemonic = mnemonic, suffix = "out"), sibling = sibling)
+
+        # NB: named ".report" as there are existing callers depending on that
+        machine_out = ctx.actions.declare_file(OUTFILE_FORMAT.format(label = target.label.name + suffix, mnemonic = mnemonic, suffix = "report"), sibling = sibling)
+
+        if ctx.attr._options[LintOptionsInfo].fail_on_violation:
+            # Fail on violation means the exit code is reported to Bazel as the action result
+            human_exit_code = None
+            machine_exit_code = None
+        else:
+            # The exit codes should instead be provided as action outputs so the build succeeds.
+            # Downstream tooling like `aspect lint` will be responsible for reading the exit codes
+            # and interpreting them.
+            human_exit_code = ctx.actions.declare_file(OUTFILE_FORMAT.format(label = target.label.name + suffix, mnemonic = mnemonic, suffix = "out.exit_code"), sibling = sibling)
+            machine_exit_code = ctx.actions.declare_file(OUTFILE_FORMAT.format(label = target.label.name + suffix, mnemonic = mnemonic, suffix = "report.exit_code"), sibling = sibling)
+
+        human_outputs = [f for f in [human_out, human_exit_code] if f]
+        machine_outputs = [f for f in [machine_out, machine_exit_code] if f]
+        return struct(
+            human = struct(
+                out = human_out,
+                exit_code = human_exit_code,
+            ),
+            machine = struct(
+                out = machine_out,
+                exit_code = machine_exit_code,
+            ),
+        ), human_outputs, machine_outputs
+
+    if files_to_lint == None:
+        s, human_outputs, machine_outputs = _declare_outputs()
+        return s, OutputGroupInfo(
+            rules_lint_human = depset(human_outputs),
+            rules_lint_machine = depset(machine_outputs),
+            # Always cause the action to execute, even if the output isn't requested
+            _validation = depset(human_outputs[0:1]),
+        )
+
+    s_out = []
+    validation_set = []
+    for f in files_to_lint:
+        f_s, f_human_outputs, f_machine_outputs = _declare_outputs("_rules_lint/" + f.short_path)
+        s_out.append(f_s)
+        human_outputs += f_human_outputs
+        machine_outputs += f_machine_outputs
+        validation_set.append(f_human_outputs[0])
+
+    return s_out, OutputGroupInfo(
         rules_lint_human = depset(human_outputs),
         rules_lint_machine = depset(machine_outputs),
         # Always cause the action to execute, even if the output isn't requested
-        _validation = depset([human_out]),
+        _validation = depset(validation_set),
     )
 
-def patch_file(mnemonic, target, ctx, sibling = None):
-    patch = ctx.actions.declare_file(OUTFILE_FORMAT.format(label = target.label.name, mnemonic = mnemonic, suffix = "patch"), sibling = sibling)
-    return patch, OutputGroupInfo(rules_lint_patch = depset([patch]))
+def patch_file(mnemonic, target, ctx, sibling = None, files_to_lint = None):
+    if files_to_lint == None:
+        patch = ctx.actions.declare_file(OUTFILE_FORMAT.format(label = target.label.name, mnemonic = mnemonic, suffix = "patch"), sibling = sibling)
+        return patch, OutputGroupInfo(rules_lint_patch = depset([patch]))
+    patches = []
+    for f in files_to_lint:
+        patches.append(ctx.actions.declare_file(OUTFILE_FORMAT.format(
+            label = target.label.name + "_rules_lint/" + f.short_path,
+            mnemonic = mnemonic,
+            suffix = "patch",
+        ), sibling = sibling))
+    return patches, OutputGroupInfo(rules_lint_patch = depset(patches))
 
 # If we return multiple OutputGroupInfo from a rule implementation, only one will get used.
 # So we need a separate function to return both.
 # buildifier: disable=function-docstring
-def patch_and_output_files(*args):
-    patch, _ = patch_file(*args)
-    outputs, _ = output_files(*args)
-    human_outputs = [f for f in [outputs.human.out, outputs.human.exit_code] if f]
-    machine_outputs = [f for f in [outputs.machine.out, outputs.machine.exit_code] if f]
-    return struct(
-        human = outputs.human,
-        machine = outputs.machine,
-        patch = patch,
-    ), OutputGroupInfo(
-        rules_lint_human = depset(human_outputs),
-        rules_lint_machine = depset(machine_outputs),
-        rules_lint_patch = depset([patch]),
-    )
+def patch_and_output_files(mnemonic, target, ctx, sibling = None, files_to_lint = None):
+    patch, _ = patch_file(mnemonic, target, ctx, sibling = sibling, files_to_lint = files_to_lint)
+    outputs, _ = output_files(mnemonic, target, ctx, sibling = sibling, files_to_lint = files_to_lint)
+    if files_to_lint == None:
+        human_outputs = [f for f in [outputs.human.out, outputs.human.exit_code] if f]
+        machine_outputs = [f for f in [outputs.machine.out, outputs.machine.exit_code] if f]
+        return struct(
+            human = outputs.human,
+            machine = outputs.machine,
+            patch = patch,
+        ), OutputGroupInfo(
+            rules_lint_human = depset(human_outputs),
+            rules_lint_machine = depset(machine_outputs),
+            rules_lint_patch = depset([patch]),
+        )
+    human_outputs = [f for o in outputs for f in [o.human.out, o.human.exit_code] if f]
+    machine_outputs = [f for o in outputs for f in [o.machine.out, o.machine.exit_code] if f]
+    return [
+        struct(
+            human = o.human,
+            machine = o.machine,
+            patch = p,
+        )
+        for o, p in zip(outputs, patch)
+    ], OutputGroupInfo(
+            rules_lint_human = depset(human_outputs),
+            rules_lint_machine = depset(machine_outputs),
+            rules_lint_patch = depset(patch),
+        )
 
 def filter_srcs(rule):
     if "lint-genfiles" in rule.attr.tags:
diff --git a/lint/private/patcher_action.bzl b/lint/private/patcher_action.bzl
index 778dfb6..ca4d4e6 100644
--- a/lint/private/patcher_action.bzl
+++ b/lint/private/patcher_action.bzl
@@ -22,7 +22,8 @@ def run_patcher(
         env = None,
         mnemonic = None,
         progress_message = None,
-        patch_cfg_suffix = "patch_cfg"):
+        patch_cfg_suffix = "patch_cfg",
+        patch_cfg_name = None):
     """Run the linter in a sandbox, in a mode where it applies fixes to source files it reads.
 
     Collects the edits made to the sandbox into a patch file.
@@ -43,10 +44,13 @@ def run_patcher(
         mnemonic: action mnemonic
         progress_message: action progress message
         patch_cfg_suffix: suffix for the patch config file name (default: "patch_cfg")
+        patch_cfg_name: patch config file name minus the suffix (default: ctx.label.name)
     """
 
     # Create a patch config file to pass arguments to the patcher.mjs script
-    patch_cfg = ctx.actions.declare_file("_{}.{}".format(ctx.label.name, patch_cfg_suffix))
+    if patch_cfg_name == None:
+        patch_cfg_name = ctx.label.name
+    patch_cfg = ctx.actions.declare_file("_{}.{}".format(patch_cfg_name, patch_cfg_suffix))
 
     # Build patch config dictionary
     patch_cfg_dict = {
